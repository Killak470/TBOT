package com.tradingbot.backend.service.strategy;

import com.tradingbot.backend.model.ScanResult;
import com.tradingbot.backend.model.TechnicalIndicator;
import com.tradingbot.backend.model.TradeSignal;
import com.tradingbot.backend.model.TradeDecision;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

/**
 * Service responsible for implementing various trading strategies and generating trade signals.
 */
@Service
public class TradingStrategyProvider {
    
    private static final Logger logger = LoggerFactory.getLogger(TradingStrategyProvider.class);
    
    /**
     * Strategy types supported by the service
     */
    public enum StrategyType {
        MOVING_AVERAGE_CROSSOVER,
        RSI_OVERSOLD_OVERBOUGHT,
        MACD_SIGNAL_CROSS,
        BOLLINGER_BAND_BREAKOUT,
        VOLUME_PRICE_CONFIRMATION,
        FIBONACCI_RETRACEMENT,
        COMBINED_TECHNICAL,
        CUSTOM
    }
    
    /**
     * Generate trade signals based on market scan results and selected strategy
     * 
     * @param scanResults Results from market scanner containing technical indicators
     * @param strategyType The strategy to apply
     * @param customParameters Any custom parameters needed for the strategy
     * @return List of trade signals generated by the strategy
     */
    public List<TradeSignal> generateSignals(List<ScanResult> scanResults, StrategyType strategyType, 
                                            Map<String, Object> customParameters) {
        
        List<TradeSignal> signals = new ArrayList<>();
        
        // Apply the selected strategy to each scan result
        for (ScanResult result : scanResults) {
            try {
                TradeSignal signal = applyStrategy(result, strategyType, customParameters);
                if (signal != null) {
                    signals.add(signal);
                }
            } catch (Exception e) {
                logger.error("Error applying strategy to {}: {}", result.getSymbol(), e.getMessage());
            }
        }
        
        return signals;
    }
    
    /**
     * Apply a specific trading strategy to a single scan result
     */
    private TradeSignal applyStrategy(ScanResult result, StrategyType strategyType, 
                                     Map<String, Object> customParameters) {
        switch (strategyType) {
            case MOVING_AVERAGE_CROSSOVER:
                return applyMovingAverageCrossover(result, customParameters);
            case RSI_OVERSOLD_OVERBOUGHT:
                return applyRsiStrategy(result, customParameters);
            case MACD_SIGNAL_CROSS:
                return applyMacdStrategy(result, customParameters);
            case BOLLINGER_BAND_BREAKOUT:
                return applyBollingerBandStrategy(result, customParameters);
            case VOLUME_PRICE_CONFIRMATION:
                return applyVolumePriceStrategy(result, customParameters);
            case FIBONACCI_RETRACEMENT:
                return applyFibonacciStrategy(result, customParameters);
            case COMBINED_TECHNICAL:
                return applyCombinedTechnicalStrategy(result, customParameters);
            case CUSTOM:
                return applyCustomStrategy(result, customParameters);
            default:
                logger.warn("Unknown strategy type: {}", strategyType);
                return null;
        }
    }
    
    /**
     * Moving Average Crossover Strategy
     * Generates buy signals when fast MA crosses above slow MA, and sell signals when it crosses below
     */
    private TradeSignal applyMovingAverageCrossover(ScanResult result, Map<String, Object> parameters) {
        // Default parameters
        int fastPeriod = parameters != null && parameters.containsKey("fastPeriod") ? 
            (int) parameters.get("fastPeriod") : 20;
        int slowPeriod = parameters != null && parameters.containsKey("slowPeriod") ? 
            (int) parameters.get("slowPeriod") : 50;
        
        // Get the indicators from scan result
        Map<String, TechnicalIndicator> indicators = result.getIndicators();
        
        // Check if we have both required MAs
        String fastMaKey = "MA_" + fastPeriod;
        String slowMaKey = "MA_" + slowPeriod;
        
        if (!indicators.containsKey(fastMaKey) || !indicators.containsKey(slowMaKey)) {
            logger.warn("Missing required MA indicators for strategy: {}, {}", fastMaKey, slowMaKey);
            return null;
        }
        
        // Get the MA values
        double fastMa = indicators.get(fastMaKey).getValue();
        double slowMa = indicators.get(slowMaKey).getValue();
        
        // Generate the trade signal
        TradeSignal signal = new TradeSignal();
        signal.setSymbol(result.getSymbol());
        signal.setPrice(result.getPrice().doubleValue());
        signal.setTimestamp(System.currentTimeMillis());
        signal.setStrategyName("Moving Average Crossover " + fastPeriod + "/" + slowPeriod);
        
        // Determine if it's a buy or sell signal
        if (fastMa > slowMa) {
            signal.setDecision(TradeDecision.BUY);
            signal.setRationale("Fast MA (" + fastMa + ") crossed above Slow MA (" + slowMa + ")");
            signal.setConfidence(calculateConfidenceScore(fastMa / slowMa - 1.0, 0.05));
        } else {
            signal.setDecision(TradeDecision.SELL);
            signal.setRationale("Fast MA (" + fastMa + ") is below Slow MA (" + slowMa + ")");
            signal.setConfidence(calculateConfidenceScore(1.0 - fastMa / slowMa, 0.05));
        }
        
        return signal;
    }
    
    /**
     * RSI Strategy
     * Generates buy signals when RSI is oversold and sell signals when it's overbought
     */
    private TradeSignal applyRsiStrategy(ScanResult result, Map<String, Object> parameters) {
        // Default parameters
        int period = parameters != null && parameters.containsKey("period") ? 
            (int) parameters.get("period") : 14;
        double oversoldThreshold = parameters != null && parameters.containsKey("oversoldThreshold") ? 
            (double) parameters.get("oversoldThreshold") : 30.0;
        double overboughtThreshold = parameters != null && parameters.containsKey("overboughtThreshold") ? 
            (double) parameters.get("overboughtThreshold") : 70.0;
        
        // Get the indicators from scan result
        Map<String, TechnicalIndicator> indicators = result.getIndicators();
        
        // Check if we have the required RSI
        String rsiKey = "RSI_" + period;
        
        if (!indicators.containsKey(rsiKey)) {
            logger.warn("Missing required RSI indicator for strategy: {}", rsiKey);
            return null;
        }
        
        // Get the RSI value
        double rsi = indicators.get(rsiKey).getValue();
        
        // Only generate signals if RSI is in oversold or overbought territories
        if (rsi < oversoldThreshold || rsi > overboughtThreshold) {
            TradeSignal signal = new TradeSignal();
            signal.setSymbol(result.getSymbol());
            signal.setPrice(result.getPrice().doubleValue());
            signal.setTimestamp(System.currentTimeMillis());
            signal.setStrategyName("RSI " + period + " Oversold/Overbought");
            
            if (rsi < oversoldThreshold) {
                signal.setDecision(TradeDecision.BUY);
                signal.setRationale("RSI (" + rsi + ") is oversold (below " + oversoldThreshold + ")");
                signal.setConfidence(calculateConfidenceScore((oversoldThreshold - rsi) / oversoldThreshold, 0.3));
            } else {
                signal.setDecision(TradeDecision.SELL);
                signal.setRationale("RSI (" + rsi + ") is overbought (above " + overboughtThreshold + ")");
                signal.setConfidence(calculateConfidenceScore((rsi - overboughtThreshold) / (100 - overboughtThreshold), 0.3));
            }
            
            return signal;
        }
        
        // No signal if RSI is in neutral territory
        return null;
    }
    
    /**
     * MACD Strategy
     * Generates signals based on MACD line crossing the signal line
     */
    private TradeSignal applyMacdStrategy(ScanResult result, Map<String, Object> parameters) {
        // Get the indicators from scan result
        Map<String, TechnicalIndicator> indicators = result.getIndicators();
        
        // Check if we have the required MACD indicator
        if (!indicators.containsKey("MACD")) {
            logger.warn("Missing required MACD indicator for strategy");
            return null;
        }
        
        // Get the MACD indicator
        TechnicalIndicator macdIndicator = indicators.get("MACD");
        
        // MACD indicator should have additional data for signal line and histogram
        Map<String, Object> additionalData = macdIndicator.getAdditionalData();
        if (additionalData == null || !additionalData.containsKey("signal") || !additionalData.containsKey("histogram")) {
            logger.warn("MACD indicator missing required additional data");
            return null;
        }
        
        // Get MACD components
        double macdLine = macdIndicator.getValue();
        double signalLine = ((Number) additionalData.get("signal")).doubleValue();
        double histogram = ((Number) additionalData.get("histogram")).doubleValue();
        
        // Only generate signal if there's a recent cross or strong divergence
        if (Math.abs(macdLine - signalLine) < 0.001) {
            return null; // No clear signal when lines are too close
        }
        
        TradeSignal signal = new TradeSignal();
        signal.setSymbol(result.getSymbol());
        signal.setPrice(result.getPrice().doubleValue());
        signal.setTimestamp(System.currentTimeMillis());
        signal.setStrategyName("MACD Signal Cross");
        
        // Determine signal type
        if (macdLine > signalLine) {
            signal.setDecision(TradeDecision.BUY);
            signal.setRationale("MACD line (" + macdLine + ") is above signal line (" + signalLine + ")");
            signal.setConfidence(calculateConfidenceScore(histogram / Math.max(0.001, Math.abs(macdLine)), 0.2));
        } else {
            signal.setDecision(TradeDecision.SELL);
            signal.setRationale("MACD line (" + macdLine + ") is below signal line (" + signalLine + ")");
            signal.setConfidence(calculateConfidenceScore(-histogram / Math.max(0.001, Math.abs(macdLine)), 0.2));
        }
        
        return signal;
    }
    
    /**
     * Bollinger Band Strategy
     * Generates signals when price breaks out of Bollinger Bands
     */
    private TradeSignal applyBollingerBandStrategy(ScanResult result, Map<String, Object> parameters) {
        // Get the indicators from scan result
        Map<String, TechnicalIndicator> indicators = result.getIndicators();
        
        // Check if we have the required Bollinger Bands indicator
        if (!indicators.containsKey("BBANDS")) {
            logger.warn("Missing required Bollinger Bands indicator for strategy");
            return null;
        }
        
        // Get the Bollinger Bands indicator
        TechnicalIndicator bbandsIndicator = indicators.get("BBANDS");
        Map<String, Object> additionalData = bbandsIndicator.getAdditionalData();
        
        if (additionalData == null || !additionalData.containsKey("upper") || !additionalData.containsKey("lower")) {
            logger.warn("Bollinger Bands indicator missing required additional data");
            return null;
        }
        
        // Get Bollinger Bands components
        double middleBand = bbandsIndicator.getValue(); // This is the SMA
        double upperBand = ((Number) additionalData.get("upper")).doubleValue();
        double lowerBand = ((Number) additionalData.get("lower")).doubleValue();
        double currentPrice = result.getPrice().doubleValue();
        
        // Only generate signals on band breakouts
        if (currentPrice > upperBand || currentPrice < lowerBand) {
            TradeSignal signal = new TradeSignal();
            signal.setSymbol(result.getSymbol());
            signal.setPrice(currentPrice);
            signal.setTimestamp(System.currentTimeMillis());
            signal.setStrategyName("Bollinger Band Breakout");
            
            if (currentPrice < lowerBand) {
                signal.setDecision(TradeDecision.BUY);
                signal.setRationale("Price (" + currentPrice + ") broke below lower band (" + lowerBand + "), indicating oversold conditions");
                signal.setConfidence(calculateConfidenceScore((lowerBand - currentPrice) / lowerBand, 0.1));
            } else {
                signal.setDecision(TradeDecision.SELL);
                signal.setRationale("Price (" + currentPrice + ") broke above upper band (" + upperBand + "), indicating overbought conditions");
                signal.setConfidence(calculateConfidenceScore((currentPrice - upperBand) / upperBand, 0.1));
            }
            
            return signal;
        }
        
        // No signal if price is within bands
        return null;
    }
    
    /**
     * Volume Price Strategy
     * Generates signals based on volume confirmation of price movements
     */
    private TradeSignal applyVolumePriceStrategy(ScanResult result, Map<String, Object> parameters) {
        // Get the indicators from scan result
        Map<String, TechnicalIndicator> indicators = result.getIndicators();
        
        // Check if we have the required Volume SMA indicator
        if (!indicators.containsKey("VOLUME_SMA")) {
            logger.warn("Missing required Volume SMA indicator for strategy");
            return null;
        }
        
        // Get the Volume indicator
        TechnicalIndicator volumeIndicator = indicators.get("VOLUME_SMA");
        String volumeSignal = volumeIndicator.getSignal();
        
        // Check if volume is significantly high or low
        if (volumeSignal.equals("NORMAL")) {
            return null; // No signal if volume is normal
        }
        
        // Get some price indicator for trend determination
        TechnicalIndicator maIndicator = null;
        if (indicators.containsKey("MA_20")) {
            maIndicator = indicators.get("MA_20");
        } else if (indicators.containsKey("MA_50")) {
            maIndicator = indicators.get("MA_50");
        }
        
        if (maIndicator == null) {
            logger.warn("Missing price trend indicator for volume-price strategy");
            return null;
        }
        
        // Get current price and determine trend
        double currentPrice = result.getPrice().doubleValue();
        double ma = maIndicator.getValue();
        boolean priceAboveMA = currentPrice > ma;
        
        // Generate signal based on volume and price relationship
        if ((volumeSignal.equals("HIGH") || volumeSignal.equals("VERY_HIGH")) && priceAboveMA) {
            // High volume with price above MA - bullish
            TradeSignal signal = new TradeSignal();
            signal.setSymbol(result.getSymbol());
            signal.setPrice(currentPrice);
            signal.setTimestamp(System.currentTimeMillis());
            signal.setStrategyName("Volume-Price Confirmation");
            signal.setDecision(TradeDecision.BUY);
            signal.setRationale("High volume confirming upward price movement above MA");
            signal.setConfidence(volumeSignal.equals("VERY_HIGH") ? 0.8 : 0.6);
            return signal;
        } else if ((volumeSignal.equals("HIGH") || volumeSignal.equals("VERY_HIGH")) && !priceAboveMA) {
            // High volume with price below MA - bearish
            TradeSignal signal = new TradeSignal();
            signal.setSymbol(result.getSymbol());
            signal.setPrice(currentPrice);
            signal.setTimestamp(System.currentTimeMillis());
            signal.setStrategyName("Volume-Price Confirmation");
            signal.setDecision(TradeDecision.SELL);
            signal.setRationale("High volume confirming downward price movement below MA");
            signal.setConfidence(volumeSignal.equals("VERY_HIGH") ? 0.8 : 0.6);
            return signal;
        }
        
        // No clear signal
        return null;
    }
    
    /**
     * Fibonacci Retracement Strategy
     * This is a simplified implementation as proper Fibonacci analysis requires trend identification
     */
    private TradeSignal applyFibonacciStrategy(ScanResult result, Map<String, Object> parameters) {
        // This would require historical data analysis to identify swing highs/lows
        // Not fully implemented in this simplified version
        return null;
    }
    
    /**
     * Combined Technical Strategy
     * Combines multiple technical indicators to generate stronger signals
     */
    private TradeSignal applyCombinedTechnicalStrategy(ScanResult result, Map<String, Object> parameters) {
        // Get the indicators from scan result
        Map<String, TechnicalIndicator> indicators = result.getIndicators();
        
        // Initialize counters for bullish and bearish signals
        int bullishCount = 0;
        int bearishCount = 0;
        
        // Check Moving Averages
        if (indicators.containsKey("MA_20") && indicators.containsKey("MA_50")) {
            double ma20 = indicators.get("MA_20").getValue();
            double ma50 = indicators.get("MA_50").getValue();
            
            if (ma20 > ma50) {
                bullishCount++;
            } else {
                bearishCount++;
            }
        }
        
        // Check RSI
        if (indicators.containsKey("RSI_14")) {
            double rsi = indicators.get("RSI_14").getValue();
            
            if (rsi < 30) {
                bullishCount++;
            } else if (rsi > 70) {
                bearishCount++;
            }
        }
        
        // Check MACD
        if (indicators.containsKey("MACD")) {
            TechnicalIndicator macdIndicator = indicators.get("MACD");
            Map<String, Object> additionalData = macdIndicator.getAdditionalData();
            
            if (additionalData != null && additionalData.containsKey("signal")) {
                double macdLine = macdIndicator.getValue();
                double signalLine = ((Number) additionalData.get("signal")).doubleValue();
                
                if (macdLine > signalLine) {
                    bullishCount++;
                } else {
                    bearishCount++;
                }
            }
        }
        
        // Check Bollinger Bands
        if (indicators.containsKey("BBANDS")) {
            TechnicalIndicator bbandsIndicator = indicators.get("BBANDS");
            Map<String, Object> additionalData = bbandsIndicator.getAdditionalData();
            
            if (additionalData != null && additionalData.containsKey("upper") && additionalData.containsKey("lower")) {
                double upperBand = ((Number) additionalData.get("upper")).doubleValue();
                double lowerBand = ((Number) additionalData.get("lower")).doubleValue();
                double currentPrice = result.getPrice().doubleValue();
                
                if (currentPrice < lowerBand) {
                    bullishCount++;
                } else if (currentPrice > upperBand) {
                    bearishCount++;
                }
            }
        }
        
        // Check Volume
        if (indicators.containsKey("VOLUME_SMA")) {
            String volumeSignal = indicators.get("VOLUME_SMA").getSignal();
            
            if (volumeSignal.equals("HIGH") || volumeSignal.equals("VERY_HIGH")) {
                // Volume alone doesn't indicate direction, but it confirms existing trends
                if (bullishCount > bearishCount) {
                    bullishCount++;
                } else if (bearishCount > bullishCount) {
                    bearishCount++;
                }
            }
        }
        
        // Generate signal if there's a clear trend (at least 2 more signals in one direction)
        if (bullishCount >= bearishCount + 2) {
            TradeSignal signal = new TradeSignal();
            signal.setSymbol(result.getSymbol());
            signal.setPrice(result.getPrice().doubleValue());
            signal.setTimestamp(System.currentTimeMillis());
            signal.setStrategyName("Combined Technical");
            signal.setDecision(TradeDecision.BUY);
            signal.setRationale("Multiple technical indicators (" + bullishCount + " vs " + bearishCount + ") showing bullish signals");
            signal.setConfidence(calculateConfidenceScore((double)(bullishCount - bearishCount) / Math.max(1, bullishCount + bearishCount), 0.3));
            return signal;
        } else if (bearishCount >= bullishCount + 2) {
            TradeSignal signal = new TradeSignal();
            signal.setSymbol(result.getSymbol());
            signal.setPrice(result.getPrice().doubleValue());
            signal.setTimestamp(System.currentTimeMillis());
            signal.setStrategyName("Combined Technical");
            signal.setDecision(TradeDecision.SELL);
            signal.setRationale("Multiple technical indicators (" + bearishCount + " vs " + bullishCount + ") showing bearish signals");
            signal.setConfidence(calculateConfidenceScore((double)(bearishCount - bullishCount) / Math.max(1, bullishCount + bearishCount), 0.3));
            return signal;
        }
        
        // No clear signal
        return null;
    }
    
    /**
     * Custom Strategy
     * Placeholder for user-defined custom strategies
     */
    private TradeSignal applyCustomStrategy(ScanResult result, Map<String, Object> parameters) {
        // Not implemented, would allow users to define custom rules
        logger.warn("Custom strategy not implemented yet");
        return null;
    }
    
    /**
     * Calculate a confidence score based on deviation from threshold
     */
    private double calculateConfidenceScore(double deviation, double scaleFactor) {
        double score = Math.min(1.0, Math.max(0.3, deviation / scaleFactor));
        return Math.round(score * 100) / 100.0; // Round to 2 decimal places
    }
} 